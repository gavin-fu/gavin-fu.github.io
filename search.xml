<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DB2数据库安装]]></title>
    <url>%2Fdatabase%2Fdb2%2Fdb2%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[环境OS: CentOS 7DB2: Express-C v10.1 (db2_v101_linuxx64_expc.tar.gz) DB2安装 解压安装包 1tar -zxvf db2_v101_linuxx64_expc.tar.gz -C /opt 执行安装db2_install 默认安装目录为 /opt/ibm/db2， 可以通过 -b指定安装目录， -h 帮助 123su - # root用户cd /opt/expc # 进入安装目录./db2_install # 以root用户安装DB2 实例实例安装 创建实例相关用户在Linux/Unix上创建实例时必须有与实例同名用户存在；实例用户的home目录，是创建实例的位置；受防护用户(db2fenc1)与应用开发相关，但是作为创建实例却是必须的。 12345# root用户执行以下命令groupadd -g 2000 db2iadm1 # 实例用户组groupadd -g 2001 db2fadm1 # 受防护组useradd -m -u 2000 -g db2iadm1 db2inst1 # 实例用户useradd -m -u 2001 -g db2fadm1 db2fenc1 # 受防护用户 实例安装可以直接键入 ./db2icrt 获取命令帮助信息；Linux/Unix下 /home/实例用户/sqllib/ 目录为实例目录，实例目录一旦创建不能更改其位置。 123# root用户执行以下命令 cd /opt/ibm/db2/V10.1/instance # 实例安装目录 ./db2icrt -p 50000 -u db2fenc1 db2inst1 # 实例安装-p &lt;端口号&gt; -u &lt;受防护用户&gt; &lt;实例用户&gt; 实例相关操作实例相关命令12345678db2ilist # 列出实例db2start # 启动实例db2stop [force] # 停止实例db2 force application all # 强制中断实例下所有连接db2iauto -[on | off] &lt;instance_name&gt; # 自动起停实例db2 attach to &lt;instance_name&gt; # 连接实例db2 detach / db2 terminate # 断开实例db2idorp &lt;instance_name&gt; # 删除实例 (需要root权限) 配置实例 配置注册变量 12345678db2set -all # 查看当前注册变量设置db2set -lr # 查询所有注册变量db2set &lt;parameter&gt;=&lt;value&gt; [-i instance_name | -g] # 设置注册变量 # [i] 实例级注册变量 # [g] 全局级注册变量 # [e] 操作系统级注册变量 # egdb2set DB2COMM=TCPIP 配置数据库管理配置文件 12345db2 get dbm cfg # 获取当前实例数据库管理文件配置db2 reset dbm cfg # 恢复默认配置db2 update dbm cfg using &lt;parameter_name&gt; &lt;value&gt; # 配置当前实例数据库管理文件参数# eg db2 update dbm cfg using SVCENAME=50000 DB2INSTANCE 变量该变量主要用于实例间切换，但在Linux/Unix系统下实例名即为实例用户名，因此直接使用不同实例用户登陆进行实例切换123echo $DB2INSTANCE # 输出变量值set DB2INSTANCE=&lt;instance_name&gt; # 设置变量值get instance # 获取当前实例 数据库创建数据库创建数据库时默认生成三个表空间 SYSCATSPACE、TEMPSPACE1、USERSPACE11234567891011CREATE DATABASE &lt;db_name&gt; -- 创建数据库 AUTOMATIC STORAGE &lt;YES | NO&gt; -- 是否自动存储 ON &lt;path | drive&gt; -- 数据库路径 ALIAS &lt;db_alias&gt; -- 别名 USING CODESET &lt;code&gt; TERRITORY &lt;territory&gt; -- 代码页 COLLATE USING &lt;SYSTEM | IDENTITY | ...&gt; -- 整理次序 CATALOG TABLESPACE &lt;tablespace_option&gt; -- 系统编目表空间 USER TABLESPACE &lt;tablespace_option&gt; -- 用户表空间 TEMPORARY TABLESPACE &lt;tablespace_option&gt; -- 临时表空间 -- 大写为关键字 示例：1234567create database test automatic storage yes on /data/db2/test_data -- 使用自动存储管理 dbpath on /data/db2/test_log -- 指定数据库的事物日志存储路径 using codeset utf-8 -- 指定字符集 territory CN -- 决定数据库的时间和日期格式为中文 pagesize 16 k -- 数据库默认页大小 alias test; -- 别名 数据库相关操作12db2 list database directory # 列出当前实例下所有数据库db2 drop database &lt;database_name&gt; # 删除数据库 表空间DB2表空间管理类型 SMS (System Managed Space) DMS (Database Managed Space) DMS自动存储 创建表空间 创建用户表空间 123456789-- SMSCREATE TABLESPACE &lt;name&gt; MANAGED BY SYSTEM USING ('&lt;path&gt;'); -- DMSCREATE TABLESPACE &lt;name&gt; MANAGED BY DATABASE USING (DEVICE | FILE '&lt;path&gt;'); - DMS自动存储CREATE TABLESPACE &lt;name&gt;; CREATE TABLESPACE &lt; name &gt; MANAGED BY AUTOMATIC STORAGE; 创建系统临时表空间 1CREATE SYSTEM TEMPORARY TABLESPACE tmp_tbsp MANAGED BY SYSTEM USING ('/data/tmp_tbsp'); 创建用户临时表空间 1CREATE USER TEMPORARY TABLESPACE usr_tbsp MANAGED BY DATABASE USING (FILE '/data/usr_tbsp' 5000); 示例12345678CREATE TEMPORARY TABLESPACE tbs_temp PAGESIZE 16K MANAGED BY DATABASE USING（FILE '/data/' 1000） EXTENTSIZE 32 OVERHEAD 10.67 PREFECHSIZE 32 TRANSFERRATE 0.04 BUFFERPOOL MYBUFFER16K； 表空间相关操作123456789101112131415161718192021222324# 1. 查看表空间db2 list tablespaces [show detail] # 查看表空间db2 list tablespace containers for &lt;tablespace_id&gt; # 查看表空间及容器属性# 2. 修改表空间# 2.1. SMS表空间只能增加容器；ALTER TABLESPACE &lt;name&gt; ADD(DEVICE &apos;&lt;path&gt;&apos; &lt;size&gt;, FILE &apos;&lt;filename&gt;&apos; &lt;size&gt;);# 2.2. DMS表空间可以调整容器；ALTER TABLESPACE &lt;name&gt; REDUCE (FILE &apos;&lt;filename&gt;&apos; &lt;size&gt;); # 缩小ALTER TABLESPACE &lt;name&gt; EXTEND (FILE &apos;&lt;filename&gt;&apos; &lt;size&gt;); # 增大ALTER TABLESPACE &lt;name&gt; RESIZE (FILE &apos;&lt;filename&gt;&apos; &lt;size&gt;); # 调增 （可调小或调大）ALTER TABLESPACE &lt;name&gt; DROP (FILE &apos;filename&apos;, DEVICE &apos;path&apos;); # 删除DMS容器# 2.3. 自动存储表空间不能手动调整大小；# 3. 重命名表空间RENAME TABLESPACE &lt;srcName&gt; TO &lt;tgtName&gt;;# 4. 将表空间从托机状态切换至联机状态ALTER TABLESPACE &lt;name&gt; SWITCH ONLINE;# 5. 删除表空间DROP TABLESPACE &lt;name&gt;; 表空间注意事项 表空间类型选择（SYSTEM / DATABASE） 选择合适的页大小(PAGESIZE) 扩展数据块大小（EXTENTSIZE） 预读大小选择（PREFECHSIZE）PREFECHSIZE = 表空间容器设备数 * 扩展数据块带小 文件系统和裸设备（CIO/DIO） 设置 容器开销 和 传送速率（OVERHEAD / TRANSFERRATE） 这两个参数用于确定查询优化期间的 I/O 成本，是所有容器的平均值，单位毫秒。 Overhead = 平均寻道时间 + (((1 / 磁盘转速) 60 1000) / 2) Transferrate = (1 / 传送速率) 1000 / 1024000 4096(假设用4K页) 表空间设计原则 对于 OLAP分析型应用，以连续大片读为主，采用较大的页面，降低 I/O请求次数； 选择 DMS大型表空间，可以灵活定义； 设置预读大小：可以在创建表空间的时候，将 PrefetchSize设置为 Automatic，预读操作在查询使用所需的数据之前读入这些数据，因为这些数据已经在内容中了，这样就不必等待执行 I/O了； 数据和索引使用不同的表空间； 每个表空间使用独立的缓冲池； 缓冲池 每个表空间都会与特定的缓冲池相关； 想要表空间与缓冲池相关，该缓冲池与表空间必须具有相同的页大小； 表空间与缓冲池关联是在使用 CREATE TABLESPACE 语句创建表空间时定义的，但是可以使用 ALTER TABLESPACE 语句更改关联。 创建缓冲池12345CREATE BUFFERPOOL &lt;bufferpool_name&gt; -- 缓冲池名称 SIZE &lt;AUTOMATIC | size_number&gt; -- 缓冲池大小，即页数 PAGESIZE &lt;pagesize&gt; -- 缓冲池页大小 BLOCKSIZE &lt;number&gt; -- 可选参数： 指定每个块的大小，即在一次块I/O中从磁盘读取的页的数量。应该等于正在使用缓冲池的表空间的 EXTENTSIZE 的整数倍。 NUMBLOCKPAGES &lt;number&gt; -- 可选参数： 定义块内存大小。应该是 BLOCKSIZE 的倍数，并且不能大于缓冲池页面数量的 98%。 示例1CREATE BUFFERPOLL MYBUFFER16K SIZE AUTOMATIC PAGESIZE 16K; 缓冲池相关操作 修改缓冲池 1ALTER BUFFERPOOL &lt;name&gt; SIZE &lt;tgt_size&gt; 查看缓冲池 12345SELECT T2.TBSPACE ,T1.*FROM SYSCAT.BUFFERPOOLS T1INNER JOIN SYSCAT.TABLESPACES T2ON T1.BUFFERPOOLID = T2.BUFFERPOOLID 配置DB2运行环境可以通过引用 InstanceHome/sqllib/db2profile 文件来配置其他用户 DB2 运行环境在用户目录下 .bash_profile 文件中加入如下配置123if [ -f /home/db2inst1/sqllib/db2profile ]; then . /home/db2inst1/sqllib/db2profilefi]]></content>
      <categories>
        <category>database</category>
        <category>db2</category>
      </categories>
      <tags>
        <tag>db2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL脚本开发规范]]></title>
    <url>%2Fsql%2Fsql%E8%84%9A%E6%9C%AC%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[良好的编码习惯可以减少出问题的几率和后期代码维护的成本 基本要求 脚本文件名称使用小写，单词与单词间使用下划线分割，最好对应于操作的表名 脚本采用 UTF-8编码， UNIX格式 脚本必须写好基本注释信息（如： 脚本功能，加载时机频率，开发人员…） 编写规范注释编写SQL脚本中无论单行、多行注释均用 –标识，不使用块状注释 / / 12345678-- 脚本名称： demo.sql-- 脚本功能： sql脚本示例-- 加载频率： d-- 创建人： gavin-- 创建时间： 2017-12-04-- 修改人：-- 修改时间：-- 修改说明： 字段排列 每个查询字段独占一行 分割字段的逗号置于字段名称之前 查询字段写好注释 12345select field1 -- 字段1 ,field2 -- 字段2 ,field3 -- 字段3from test.demo -- 示例表; 子句排列同一级别的子句要对齐 123456789select a.field1 -- 字段1 ,a.field2 -- 字段2 ,b.field3 -- 字段3from test.tab1 a -- 表1inner join test.tab2 b -- 表2on a.field1 = b.field1where a.field2 = ''order by a.field1; 子句查询嵌套子句嵌套编排做好层次分明 12345678910select a.field1 -- 字段1 ,a.field2 -- 字段2 ,a.field3 -- 字段3from test.tab1 a -- 表1where a.field2 = ''and exists ( select 1 from test.tab2 b -- 表2 where a.field1 = b.field1 ); 字段别名 如查询字段的名称与目标表字段名称不一致，则使用 AS为字段命别名 若查询字段或表达式过长，则 AS最好分行对齐 123456789101112insert into test.tgt ( -- 目标表 field1 -- 字段1 ,field2 -- 字段2 ,field3 -- 字段3)select field1 ,'xxx' AS field2 ,express1 || express2 || express 3 AS field3from test.src -- 目标表;commit; 表别名多表嵌套查询需体现层次结构，可为表命别名。使用字母 a-z标明层次, 同一层次间使用数字标明序号 1234567891011select a1.field1 -- 字段1 a2.field2 -- 字段2from test.tab1 a1innser join ( select b1.field2 as field1 ,b2.field2 from test.tab2 b1 inner join test.tab3 b2 on b1.field1 = b2.field1 ) a2on a1.field1 = a2.field1; 特殊表命名规范 历史表： 以h结尾 临时表： 以tmp结尾 备份表： 以8位备份日期结尾]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Class对象]]></title>
    <url>%2Fjava%2Fclass%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[概述 每个类都有一个Class对象； 类Class对象是由JVM的子系统 “类加载器”生成的。 类加载器类加载器实际上可以包含一条加载器链，但是只有一个原声类加载器，可以挂接额外类加载器 原生类加载器原生类加载的是所谓的可信类，如：JavaAPI等 额外类加载器额外类加载器用来满足自身的特殊需求，如：以某种特殊方式加载类，以支持WEB服务器应用等 类的动态加载类的动态加载分为三个步骤： 加载由类加载器执行，该步骤将查找字节码，并从字节码中创建一个Class对象 链接链接将验证类中的字节码，为静态域分配存储空间，并且如果必须的话将解析这个类创建其它类的所有引用 初始化如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块 “惰性”初始化当程序创建第一个对类的静态成员的引用时，就会 加载 该类；根据java虚拟机规范，所有java虚拟机实现必须在每个类或接口被java程序首次 主动使用 时才初始化。 主动使用有如下几种 创建类的实例 访问某个类或者接口的静态域（静态变量、方法） 如果访问静态编译时常量(static final)不会导致类的初始化 构造方法也是类的静态方法，因此使用 new关键字会被当成是对静态成员的引用 12345678910111213141516171819202122232425262728293031323334package org.gavin.clazz;class LazyInitialization1 &#123; static final int FIELD = 0; static int FIELD1 = 1; static &#123; System.out.println("Initial"); &#125;&#125;/** * &lt;p&gt;如果 static域是final的，那么不对类进行初始化也可以进行读取； * &lt;p&gt;若 static域不是final的，那在读取之前进行链接（为这个域分配空间）和初始化（初始化该空间）。 * * @author gavin */public class ClassInitialize1 &#123; public static void main(String[] args) &#123; System.out.println("static final"); System.out.println(LazyInitialization1.FIELD); System.out.println("static"); System.out.println(LazyInitialization1.FIELD1); &#125;&#125;// 输出结果：static final0staticInitial1 反射（Class.forName(xxx.xxx.xxx)） 123456789101112131415161718192021222324252627282930package org.gavin.clazz;class LazyInitialization &#123; static &#123; System.out.println("Initial"); &#125;&#125;/** * &lt;p&gt;使用类字面常量 .class 来创建对Class对象的引用时，不会自动初始化该Class对象; * &lt;p&gt;但是使用 Class.forName() 会立即进行初始化。 * * @author gavin */public class ClassInitialize &#123; @SuppressWarnings("unused") public static void main(String[] args) throws ClassNotFoundException&#123; System.out.println(".class"); Class&lt;LazyInitialization&gt; clazz = LazyInitialization.class; System.out.println("Class.forName()"); Class.forName("org.gavin.clazz.LazyInitialization"); &#125;&#125;// 输出结果：.classClass.forName()Initial 初始化一个类的子类（相当于对父类的主动使用），不过直接通过子类引用父类元素，不会引起子类的初始化 123456789101112131415161718192021222324252627package org.gavin.clazz;class Parent &#123; static int field = 0; static &#123; System.out.println("parent"); &#125;&#125;class Child extends Parent&#123; static &#123; System.out.println("child"); &#125;&#125;/** *当访问一个Java类或接口的静态域时，只有真正声明这个域的类或接口才会被初始化 */public class ClassInitialize2 &#123; public static void main(String[] args) &#123; System.out.println(Child.field); &#125;&#125;// 输出结果：parent0 Java虚拟机被标明为启动类的类（包含main方法的类） 获取Class对象 类字面量常量 .class 反射 Class.forName( ) 实例对象 obj.getClass 参考 Java编程思想 （14章）Java系列笔记(1) - Java 类加载与初始化]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA基础</tag>
      </tags>
  </entry>
</search>
