<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Shell编程 — 数组]]></title>
    <url>%2Fshell%2Fshell%E7%BC%96%E7%A8%8B%E2%80%94%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[Shell编程之数组 在 Shell中数组分为 普通数组、关联数组 两种普通数组的索引只能是整数类型，下标从0开始关联数组的索引可以使用字符串类型，Bash从4.0版本开始支持关联数组 定义数组12345# 定义普通数组declare -a array# 定义关联数组declare -A array 初始化数组普通数组12345678910111213141516171819# 方式一# 使用默认分隔符（IFS）初始化数组# 可以不定义（declare -a），而直接初始化数组arr=(a b c)# 自定义分隔符初始化数组# 数组必须先定义，后赋值OLDIFS=$IFSIFS=','declare -a arr2=(a,b,c)IFS=$OLDIFS# 方式二# 根据元素索引进行初始化# 数组也可以不定义，而直接初始化arr3[0]=aarr3[1]=barr3[2]=c 关联数组123456789# 方式一# 可以不定义，而直接初始化arr=([index1]=1 [index2]=2 [index3]=3)# 方式二# 可以不定义，而直接初始化arr2['1']=aarr2['2']=barr2['3']=c 读取数组普通数组与关联数组通用操作1234567891011121314151617181920# 获取特定元素echo $&#123;array[index]&#125;# 获取数组中所有元素echo $&#123;array[@]&#125;echo $&#123;array[*]&#125;# 获取数组索引echo $&#123;!array[@]&#125;echo $&#123;!array[*]&#125;# 获取数组长度echo $&#123;#array[*]&#125;echo $&#123;#array[@]&#125;# 遍历数组# 使用for循环遍历数组，只能使用 $&#123;array[@]&#125;，而不能使用 $&#123;array[*]&#125;for i in "$&#123;array[@]&#125;"; do echo $idone]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell编程 — 循环语句]]></title>
    <url>%2Fshell%2Fshell%E7%BC%96%E7%A8%8B%E2%80%94%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[Shell编程之循环语句 forShell中的for循环有两种格式123456789# 格式一for i list; do commandsdone# 格式二for (( i=0; i&lt;10; i++ )) &#123; commands&#125; 示例12345678910111213141516171819202122232425# 遍历序列# &#123;1..5&#125;/&#123;a..z&#125;/&#123;A..Z&#125; 生成序列for i in &#123;a..c&#125;; do echo "$i"done# 遍历参数# "#@" 与 "$*" 效果一致，但是使用 "$*"时一定注意加上双引号for i in "$@"; do echo "$i"donedeclare -a arr=(a b c)# 遍历数组# "$&#123;arr[@]&#125;" 获取数组所有元素for i in "$&#123;arr[@]&#125;"; do echo "$i"done# 遍历数组# "$&#123;#arr[@]&#125;" 获取数组元素个数for((i=0; i&lt;"$&#123;#arr[@]&#125;"; i++)) &#123; echo "$&#123;arr[i]&#125;"&#125; while若条件不为真，则退出循环123while condition; do commandsdone 示例123456declare -i i=0while [ $i -lt 3 ]; do echo $i let i++ done until若条件为真，则退出循环123until condition; do commandsdone 示例123456declare -i i=0until [ $i -eq 3 ]; do echo $i let i++ done]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell编程 — 变量]]></title>
    <url>%2Fshell%2Fshell%E7%BC%96%E7%A8%8B%E2%80%94%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[Shell编程之变量 Bash常见的内部变量可使用 set、declare、typeset 命令查看内部变量可使用 env 查看环境变量 Bash内部变量 说明 $BASH 用于引用Bash实例的全路径名 $HOME 当前用户的home目录 $IFS IFS是内部字段分隔符的缩写。此变量决定当Bash解析字符串时将怎样识别字段，或单词分界线。变量$IFS的默认值是空格（空格、制表符和换行） $SECONDS 脚本已经运行的秒数 $OSTYPE 操作系统的类型 $TMOUT 如果$TMOUT变量被指定了一个非零的值，此值就会被Bash的内部命令read作为默认的超时秒数。在一个交互式的Shell中，$TMOUT的值被作为命令行提示符等待输入的秒数，如果在指定的秒数内没有输入，Bash将自动被终结。 $UID 当前用户的账号标识码（ID号），与/etc/passwd中记录的相同 Bash中的特殊参数 特殊参数 说明 $* 将扩展为从1开始的所有位置参数。如果扩展发生在双引号内，即“$*”，则扩展为包含每个参数值的单词，每个参数值用特殊变量IFS的第一个字符分隔; $@ 将扩展为从1开始的所有位置参数。但当它的扩展发生在双引号内时，每个参数都扩展为分隔的单词。也就是，“$@”等价于“$1”、“$2”…。参数@与*之间的区别将在for循环的调用中显现出来; $# 将扩展为位置参数的个数，用十进制表示; $? 将扩展为最近一个在前台执行的命令的退出状态; $- 将扩展为当前的选项标志。这些选项是在调用时，或由内部命令set指定，或由Shell自身指定; $$ 将扩展为当前Shell的进程号。在一个子Shell中，它扩展为调用Shell的进程号，而不是子Shell的进程号; $! 将扩展为最近一次执行的后台命令的进程号; $0 将扩展为Shell或Shell脚本的名称; $_ 在Shell启动时，它被设为开始运行的Shell或Shell脚本的路径。随后，扩展为前一个命令的最后一个参数; $*与$@ 在 for 循环中的区别123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/bin/env bash# file: for-demo.sh# usage: ./for-demo.sh [parameters]# desc: ---# author: gavin# created: 2017/12/14echo 'test: $*'declare -i index=0for i in $*; do let index++ echo "$&#123;index&#125; : $&#123;i&#125;"doneecho 'test: "$*"'index=0for i in "$*"; do let index++ echo "$&#123;index&#125; : $&#123;i&#125;"doneecho 'test: $@'index=0for i in $@; do let index++ echo "$&#123;index&#125; : $&#123;i&#125;"doneecho 'test: "$@"'index=0for i in "$@"; do let index++ echo "$&#123;index&#125; : $&#123;i&#125;"done# 执行脚本：[gavin@localhost tmp]$ ./for-demo.sh a b ctest: $*1 : a2 : b3 : ctest: "$*"1 : a b ctest: $@1 : a2 : b3 : ctest: "$@"1 : a2 : b3 : c declare / typeset 定义变量declare 与 typeset 功能一致，都是定义变量的类型； 在默认的情况下面， bash 对于变量有几个基本的定义： 变量类型默认为“字串”，所以若不指定变量类型，则 1+2 为一个“字串”而不是“计算式”。 bash 环境中的数值运算，默认最多仅能到达整数形态，所以 1/3 结果是 0； 语法12345678910declare [-aAfFgilrtux] [-p] [name[=value] ...]typeset [-aAfFgilrtux] [-p] [name[=value] ...]常用选项与参数：-a ：定义为普通数组（普通数组只能使用整数作为数组下标,起始下标为 0）-A ：定义为关联数组（关联数组可以使用字符串作为数组索引,Bash从4.0版本开始支持关联数组）-i ：定义成为整数数字-x ：用法与 export 一样，就是将后面的 variable 变成环境变量；-r ：将变量设置成为 readonly 类型，该变量不可被更改内容，也不能 unset-p ：打印变量内容 示例123456789# 定义变量[gavin@localhost test]$ declare -i num=10# 打印变量内容[gavin@localhost test]$ declare -p numdeclare -i num="10"[gavin@localhost test]$ declare -p BASHdeclare -- BASH="/bin/bash" 参考 Linux Shell命令行及脚本编程实例详解 （第5章）鸟哥的Linux私房菜 基础学习篇 （第10章）]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell编程 — 变量进阶]]></title>
    <url>%2Fshell%2Fshell%E7%BC%96%E7%A8%8B%E2%80%94%E5%8F%98%E9%87%8F%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[shell编程之变量进阶 间接参数扩展${!parameter}上述语句中，被引用的参数不是PARAMETER自身，而是PARAMETER的值 示例1234[gavin@localhost ~]$ temp='hello world'[gavin@localhost ~]$ parameter=temp[gavin@localhost ~]$ echo $&#123;!parameter&#125;hello world # 被引用的变量是 temp 上述效果等同于如下命令12[gavin@localhost ~]$ eval echo \$&#123;$parameter&#125;hello world 变量名扩展${!PREFIX*}${!PREFIX@}这种参数扩展将列出以字符串PREFIX开头的所有变量名 示例12345[gavin@localhost ~]$ echo $&#123;!BASH*&#125;BASH BASHOPTS BASHPID BASH_ALIASES BASH_ARGC BASH_ARGV BASH_CMDS BASH_COMMAND BASH_COMPLETION_COMPAT_DIR BASH_LINENO BASH_SOURCE BASH_SUBSHELL BASH_VERSINFO BASH_VERSION[gavin@localhost ~]$ echo $&#123;!BASH@&#125;BASH BASHOPTS BASHPID BASH_ALIASES BASH_ARGC BASH_ARGV BASH_CMDS BASH_COMMAND BASH_COMPLETION_COMPAT_DIR BASH_LINENO BASH_SOURCE BASH_SUBSHELL BASH_VERSINFO BASH_VERSION 大小写修改（bash 4.0 新特性）${PARAMETER^} ：将变量的第一个字符改为大写${PARAMETER^^} ：将变量全部内容改为大写${PARAMETER,} ：将变量的第一个字符改为小写${PARAMETER,,} ：将变量全部内容改为小写${PARAMETER~} ：对变量中每个单词首字母大小写取反（单词之间根据空格划分）${PARAMETER~~} ：对变量内容大小写进行取反 示例12345678910111213[gavin@localhost ~]$ var='hello world'[gavin@localhost ~]$ echo $&#123;var^&#125; # 将变量的第一个字符改为大写Hello world[gavin@localhost ~]$ echo $&#123;var^^&#125; # 将变量全部内容改为大写HELLO WORLD[gavin@localhost ~]$ echo $&#123;var,&#125; # 将变量的第一个字符改为小写hello world[gavin@localhost ~]$ echo $&#123;var,,&#125; # 将变量全部内容改为小写hello world[gavin@localhost ~]$ echo $&#123;var~&#125; # 对变量中每个单词首字母大小写取反Hello World[gavin@localhost ~]$ echo $&#123;var~~&#125; # 对变量内容大小写进行取反HELLO WORLD 字符串移除${PARAMETER#PATTERN} ：从前至后，最短匹配移除${PARAMETER##PATTERN} ：从前至后，最长匹配移除${PARAMETER%PATTERN} ：从后往前，最短匹配移除${PARAMETER%%PATTERN} ：从后往前，最长匹配移除 记忆方式： #键在前，所以从前至后； %键在后，所以从后至前 示例123456789[gavin@localhost ~]$ file='/home/gavin/batch/script/file.txt'[gavin@localhost ~]$ echo $&#123;file#*/&#125; # 从前向后最短匹配(*/)home/gavin/batch/script/file.txt[gavin@localhost ~]$ echo $&#123;file##*/&#125; # 从前向后最长匹配(*/)file.txt[gavin@localhost ~]$ echo $&#123;file%/*&#125; # 从后向前最短匹配(/*)/home/gavin/batch/script[gavin@localhost ~]$ echo $&#123;file%%/*&#125; # 从后向前最长匹配(/*) # 变量字符串全部移除 字符串截取${PARAMETER:OFFSET} ：从指定位置截取至末尾${PARAMETER:OFFSET:LENGTH} ：从指定位置截取指定长度 起始字符的索引从0开始计数。我们也可以从后向前计数,将最后一个字符索引记为 -1如果使用负数作为索引值的话,必须将负数放入括号内，或者使用 0-n方式 示例123456789[gavin@localhost ~]$ var="This is a line of text"[gavin@localhost ~]$ echo $&#123;var:5&#125;is a line of text[gavin@localhost ~]$ echo $&#123;var:0:4&#125;This[gavin@localhost ~]$ echo $&#123;var:(-4)&#125;text[gavin@localhost ~]$ echo $&#123;var:0-4&#125;text 字符串删除与替换${PARAMETER/PATTERN/STRING} ：替换第一个匹配的字符串${PARAMETER//PATTERN/STRING} ：替换所有匹配的字符串${PARAMETER/PATTERN} ：删除第一个匹配的字符串${PARAMETER//PATTERN} ：删除所有匹配的字符串 示例123456789[gavin@localhost ~]$ var=aabbcc[gavin@localhost ~]$ echo $&#123;var/a/A&#125;Aabbcc[gavin@localhost ~]$ echo $&#123;var//a/A&#125;AAbbcc[gavin@localhost ~]$ echo $&#123;var/a&#125;abbcc[gavin@localhost ~]$ echo $&#123;var//[a-z]&#125; # 删除变量中所有的 a-z 字符 # 变量字符串全部删除 字符串长度${#string}获取变量字符穿长度 示例 123[gavin@localhost ~]$ var='啊AA'[gavin@localhost ~]$ echo $&#123;#var&#125;3 变量的测试与内容替换 变量设置方式 str未定义 str为空字串 str已设置非为空字串 var=${str-expr} var=expr var= var=$str var=${str:-expr} var=expr var=expr var=$str var=${str+expr} var= var=expr var=expr var=${str:+expr} var= var= var=expr var=${str=expr} str=expr str 不变 str 不变 var=${str=expr} var=expr var= var=$str var=${str:=expr} str=expr str=expr str 不变 var=${str:=expr} var=expr var=expr var=$str var=${str?expr} expr 输出至 stderr var= var=$str var=${str:?expr} expr 输出至 stderr expr 输出至 stderr var=$str 示例1234567891011121314151617181920212223242526272829303132[gavin@localhost ~]$ unset null # 变量 null 未定义[gavin@localhost ~]$ blank= # 变量 blank 为空串[gavin@localhost ~]$ blank1='' # 变量 blank1 为空串[gavin@localhost ~]$ var=string # 变量 var 设置为非空字串[gavin@localhost ~]$ echo $&#123;null-word&#125;word[gavin@localhost ~]$ echo $&#123;blank-word&#125; # 空串[gavin@localhost ~]$ echo $&#123;var-word&#125;string[gavin@localhost ~]$ echo $&#123;null:-word&#125;word[gavin@localhost ~]$ echo $&#123;blank:-word&#125;word[gavin@localhost ~]$ echo $&#123;var:-word&#125;string[gavin@localhost ~]$ echo $&#123;null+word&#125; # 空串[gavin@localhost ~]$ echo $&#123;blank+word&#125;word[gavin@localhost ~]$ echo $&#123;var+word&#125;word[gavin@localhost ~]$ echo $&#123;null:+word&#125; # 空串[gavin@localhost ~]$ echo $&#123;blank:+word&#125; # 空串[gavin@localhost ~]$ echo $&#123;var:+word&#125;word 参考 Linux Shell命令行及脚本编程实例详解 （第5章）鸟哥的Linux私房菜 基础学习篇 （第10章）]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell编程 — 判断语句]]></title>
    <url>%2Fshell%2Fshell%E7%BC%96%E7%A8%8B%E2%80%94%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[Shell编程之判断语句 判断语句if 语句if123if condition; then commandfi if else12345if condition; then command1else command2fi if else-if1234567if condition1; then command1elif condition2; then command2else commandNfi &amp;&amp; || 语句123456condition &amp;&amp; command; # 如果condition为真,则执行commandcondition || command1; # 如果condition为假,则执行command# 可用以下语句替代 if else 语句# 如果condition为真,则执行command1,否则执行command2condition &amp;&amp; command1 || command2; 若执行判断失败，需要退出shell可写成如下形式12[ 1 -eq 1 ] &amp;&amp; echo "true" || &#123; echo "false"; exit 1 &#125;# 大括号(&#123;&#125;)内侧两边必须保留一个空格，语句1（echo "false";）与语句2（exit 1）之间必须保留一个空格 切不可写成如下形式:[ 1 -eq 1 ] &amp;&amp; echo “true” || $(echo “false”; exit 1)退出的是子shell，并不是当前shell case 语句12345678910case 值 in 模式1) command1 ;; 模式2） command2 ;; *) ;;esac 判断条件文件判断 判断符 说明 -e file 如果file存在则为真 -f file 如果file存在且为普通文件则为真 -d file 如果file存在且为目录则为真 -c file 如果file存在且为字符型特殊文件则为真 -b file 如果file存在且为特殊块文件则为真 -p file 如果file存在且为命名管道文件则为真 -S file 如果file存在且为套接字文件则为真 -L file 如果file存在且为符号链接则为真（与-h一致） -h file 如果file存在且为符号连接则为真（与-L一致） -r file 如果file存在且可读则为真 -w file 如果file存在且可写则为真 -x file 如果file存在且可执行则为真 -s file 如果file存在且至少有一个字符则为真 -g file 如果file存在且设置了 sgid位则为真 -u file 如果file存在且设置了 suid位则为真 -t fd 如果文件描述已打开且引用了一个终端则为真 file1 -nt file2 如果file1比file2新则为真（指mtime） file1 -ot file2 如果file1比file2旧则为真（指mtime） file1 -ef file2 如果file1有硬链接到file2则为真 字符串判断 判断符 说明 -z string string为空则为真 -n string string不为空则为真 string1 = string2 等于则为真 string1 != string1 不相等则为真 string1 &gt; string2 如果string1的字典排序在string2之前则为真（ASCII码顺序） string1 &lt; string2 如果string1的字典排序在string2之后则为真（ASCII码顺序） 数值判断 判断符 说明 -eq 等于则为真 -ne 不等于则为真 -gt 大于则为真 -ge 大于等于则为真 -lt 小于则为真 -le 小于等于则为真 AND 与 ORAND: -a 等价于 &amp;&amp;OR: -o 等价于 || 使用 [[ ]]判断时，只能使用 &amp;&amp; 、|| []： [ 1 -eq 1 ] &amp;&amp; [ 2 -eq 2 ] [ 1 -eq 1 -a 2 -eq 2 ] [[]]: [[ 1 = 1 ]] &amp;&amp; [[ 2 = 2 ]] [[ 1 = 1 -a 2 = 2 ]] [] 与 [[]] 区别[] 几乎在任何shell中都可以用，但是 [[]]仅在 Bash、Zsh和Ksh中可用[[]] 是 [] 的高级版，字符比较最好使用 [[]] []与[[]]之间的异同 特性 [[ ]] [ ] String comparison &gt; \&gt; String comparison &lt; \&lt; Expression grouping ( ) \( \) Pattern matching = not available regular Expression =~ not available 注：使用 -eq、-lt、-gt ……等数值判断符时，需要确保判断符两侧为整数类型,或可以转换为整数的字符串，否则： 在 []、test 中直接直接报错（integer expression expected） 在 [[ ]] 中，非整数类型会或不能转换为整数的字符串，将会转换为0之后再进行判断 参考 Linux Shell命令行及脚本编程实例详解 （第6章）]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DB2数据库对象 — 索引]]></title>
    <url>%2Fdatabase%2Fdb2%2Fdb2%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1%E2%80%94%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[DB2数据库对象 —— 索引 索引概述使用索引的目的 确保一个或多个列中值的唯一性； 提高查询性能。 使用索引注意事项 每个索引都需要占用存储器或磁盘空间； 对表执行每个 INSERT、DELETE 操作都要对表上的索引进行额外的变更，对于更新索引键值每个 UPDATE 操作也是如此； 对于 LOAD 操作会重建索引，可以在 LOAD 命令中指定 index freespace MODIFIED BY 参数，以覆盖创建索引时使用的索引 PCTFREE。 索引访问机制至少有一个SQL谓词必须是可索引的。某些谓词因特性而不能被索引，所以优化器不能使用索引来满足；其中一列（在任何可索引的谓词中）必须作为可用索引中的列而存在。 直接索引查找（最简单）对DB2而言，为了直接执行“直接索引查找”，在查询的 WHERE 子句中必须为每个索引列供值，即：索引列必须全部出现在 WHERE子句之中；若 WHERE 子句只指定了部分索引列，那么就不能采用直接索引查找，因为DB2没有针对每列的值，不能匹配整个索引关键字；若 WHERE 子句只指定了部分索引列，可以选用索引扫描（匹配索引扫描、非匹配索引扫描）。 匹配索引扫描（绝对定位）使用匹配索引扫描必须在 WHERE 条件中指定索引的”高次序列”，即：首列。这向DB2提供了遍历索引结构的起始点，从根页开始遍历，直到相应的叶子页。 非匹配索引扫描（相对定位）若 WHERE 条件中未指定索引的“高次序列”，则会使用非匹配索引扫描。在这种情况下DB2不能使用索引树结构，因为索引关键字中的第一列不可用。非匹配索引扫描从索引中的第一个叶子页开始遍历，应用可用的谓词，顺序扫描后续的叶子页。不使用根页和任何中间叶子页。 完全索引访问（index access only)当查询语句中所需要的数据都位于索引中(即： SELECT的字段)，那么DB2可以避免读取数据页 多索引访问当查询 WHERE子句中存在多个列，但多列位于不同的索引中，那么该查询将同时使用多个索引进行查询。根据谓词是用 AND连接 还是 OR连接，可以将多索引访问分为两类： IndexANDINGIndexANDING是先使用索引1和索引2获取到索引的扫描结果，再将两个扫描结果获取交集 IndexORDINGIndexANDING是先使用索引1和索引2获取到索引的扫描结果，再将扫描结果执行合并操作 简单案例定义 EMPLOYEE表，该表有关于 EMPNO、TYPE、EMPCODE列的索引 直接索引查找1SELECT FIELD1, FIELD2 FROM EMPLOYEE WHERE EMPNO = 'XXX' AND TYPE = 'XXX' AND EMPCODE = 'XXX'; 匹配索引扫描1SELECT FIELD1, FIELD2 FROM EMPLOYEE WHERE EMPNO = 'XXX' AND TYPE = 'XXX'; 非匹配索引扫描1SELECT FIELD1, FIELD2 FROM EMPLOYEE WHERE TYPE = 'XXX' AND EMPCODE = 'XXX'; 创建索引集群索引 集群索引 数据页中的顺序对应于索引中行的顺序，因此表中只能存在一个集群索引； 通常情况下，INSERT操作越多，为维护集群所需要的PCTFREE值越大； 将表设置为追加方式可能优于使用集群索引（ALTER TABLE APPEND ON）; 1CREATE INDEX &lt;index_name&gt; ON &lt;table_name&gt; (&lt;column&gt;) CLUSTER 双向索引默认情况下，双向索引允许按正反两个方向进行扫描1CREATE INDEX &lt;index_name&gt; ON &lt;table_name&gt; ( &lt;column&gt; [DESC] ) ALLOW REVERSE SCANS; 创建索引选项INCLUDENCLUDE 子句在创建索引时，可以选择包含附加的列数据，这些附加的列数据将与键存储在一起，但实际上不是键自身的一部分，所以不被排序。1CREATE INDEX &lt;index_name&gt; ON &lt;table&gt; ( &lt;column&gt; ) INCLUDE ( &lt;column&gt; ) MINPCTUSEDMINPCTUSED 子句指定在索引页上最小已用空间的阀值 CREATE INDEX &lt;index_name&gt; ON &lt;table_name&gt; (&lt;column&gt;) MINPCTUSED &lt;20&gt; ; 当从这个索引删除关键字时，如果这个索引页上的其余关键字占用索引页上的 20% 或更小的空间，那么就可以尝试将这个索引页的关键字与相邻索引的关键字合并，从而删除这个索引页。 创建索引的建议 根据查询使用的列建立索引一般情况根据谓词的选择度来排列索引中各列的位置，选择度大的谓词使用的列放索引前面，把那些只存在于SELECT语句中的列放在索引的最后。 根据条件语句中的谓词的选择度创建索引选择度越大，索引性能越好。如果选择度较低可能优化器将采取全表扫描而不是索引扫描。 避免在建有索引的列上使用函数 在需要排序的列上创建索引这里的排序不仅仅指 ORDER BY 子句，还包括 DISTINCT 、UNION 和 GROUP UP 子句，它们都会产生排序操作。 合理使用 INCLUDE 关键字创建索引 指定索引的排序属性 参考 循序渐进DB2 （第5章）]]></content>
      <categories>
        <category>Database</category>
        <category>DB2</category>
      </categories>
      <tags>
        <tag>DB2</tag>
        <tag>Index</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DB2数据库对象 — 表]]></title>
    <url>%2Fdatabase%2Fdb2%2Fdb2%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1%E2%80%94%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[DB2数据库对象 —— 表 表设计生成列生成列在表中定义，在这些列中，存储的值是使用表达式计算得出的，而不是通过插入或更新操作指定123456CREATE TABLE test.test1( field1 INT, field2 INT, create_field1 INT GENERATED ALWAYS AS (field1 + field2), create_field2 INT GENERATED ALWAYS AS (CASE WHEN field1 &gt; field2 THEN 0 ELSE 1 END)); 生成列 标识列标识列为 DB2提供一种方法，可自动为添加至表的每一行生成唯一数值1234CREATE TABLE test.test2( field1 INT GENERATED ALWAYS AS IDENTITY(START WITH 1, INCREMENT BY 1), field2 VARCHAR(10)); 使用 GENERATED ALWAYS 定义的列始终由 DB2数据库管理器生成值，不允许用户或程序显式提供（不允许Insert值） 1234CREATE TABLE test.test3( field1 INT GENERATED BY DEFAULT AS IDENTITY, field2 VARCHAR(10)); 使用 GENERATED BY DEFAULT 定义的列可以由 DB2数据库生成值，但也允许用户或程序显式的提供该值（可以Insert值） 自动编号和标识列 not null with default123CREATE TABLE test.test( field1 VARCHAR(10) NOT NULL WITH DEFAULT '1'); not logged initially1. 创建不记日志表1234CREATE TABLE test.test4( field1 INT, field2 VARCHAR(10))NOT LOGGED INITIALLY; NOT LOGGED INITIALLY 激活后，如果此表相关语句失败（导致rollback），或者 ROLLBACK TO SAVEPOINT 被执行，那么整个事物将被回滚，并且被激活 NOT LOGGED INITIALLY 属性的表将被标记为不可访问，此表只能被删除并重建。 2. 在事物中激活不记日志特性，仅当前事务不记日志1ALTER TABLE test.test3 ACTIVATE NOT LOGGED INITIALLY; 3. 不记日志清空表12ALTER TABLE test.test3 ACTIVATE NOT LOGGED INITIALLY WITH EMPTY TABLE;TRUNCATE TABLE test.test3 IMMEDIATE; append on在DB2中，当表的数据被删除时，空间并不会释放，而是在原来位置做个删除标志，表示该空间可以重用。当执行 Insert语句时，会扫描空闲空间并将新行置入。而启用 append on特性后，那么 执行插入时不会扫描空间空间，而是直接插入到表的最后。1ALTER TABLE test.test3 APPEND &lt; ON | OFF &gt;; 打开 APPEND ON 属性时，表不能有集群索引；启用该属性，考虑定期 REORG 表。 pctfree为每页预留可用空间，应付 row overflow如果没有进行指定，默认预留 10%的空闲空12ALTER TABLE test.test3 PCTFREE 10;ALTER TABLE test.test3 PCTFREE 0; --只读表 OVERFLOW 假如字段 name的数据类型为 VARCHAR(60),如果一开始 name长度为10个字节，这时值假设刚刚可以放到一个数据页中。但是假如有一个 update操作将 name从10字节更新为60字节，如果这个数据页无法放下，那么数据库就在当前位置存放一个指针，把数据放到一个新的数据页中，这个就叫 overflow。overflow会增加 I/O的读取，对性能不好。 volatile如果表数据量经常变化非常大，导致统计信息不准确而不能执行索引扫描，那么启用 volatile特性后，优化器将考虑使用索引扫描而不是表扫描1ALTER TABLE test.test3 VOLATILE CARDINALITY; 对于这样的表，DB2在以下情况将执行索引扫描代替表扫描，而不考虑统计信息： 引用的所有列都是索引的组成部分 索引可以在索引扫描期间应用谓词 可以在 SYSCAT.TABLES 中查询出 “PCTFREE”、”LOCKSIZE“、”VOLATILE“、”APPEND ON“ 等信息 表维护创建表123456789CREATE TABLE test.tab ( field1 INT NOT NULL ,field2 VARCHAR(255) ,CONSTRAINT pk_test_tab PRIMARY KEY (field1)) IN data_spac INDEX IN index_spac;COMMENT ON TABLE test.tab IS '示例表';COMMENT ON COLUMN test.tab.field1 IS '字段1';COMMENT ON COLUMN test.tab.field2 IS '字段2'; 1CREATE TABLE &lt;table&gt; LIKE &lt;tgtTable&gt; 上述命令产生的新表不会自动创建表中部分的附属对象（唯一约束、外键约束、触发器、索引） 查询表123456789101112-- 获取表list tables [for all | for schema &lt;schema&gt;]-- 获取表结构describe table &lt;table&gt;-- 获取DDL信息db2look -d &lt;database&gt; -t &lt;table&gt; -e-- 相关系统表SYSCAT.TABLESSYSCAT.COLUMNS 修改表12345678910111213141516171819-- 删除字段ALTER TABLE &lt;table&gt; DROP COLUMN &lt;column&gt;;-- 新增字段ALTER TABLE &lt;table&gt; ADD COLUMN &lt;column&gt; &lt;type&gt;;-- 修改字段类型ALTER TABLE &lt;table&gt; ALTER COLUMN &lt;column&gt; SET DATA TYPE &lt;type&gt;;-- 设置非空约束ALTER TABLE &lt;table&gt; ALTER COLUMN &lt;column&gt; SET NOT NULL;ALTER TABLE &lt;table&gt; ALTER COLUMN &lt;column&gt; DROP NOT NULL;-- 修改字段名ALTER TABLE &lt;table&gt; RENAME COLUMN &lt;oldColumn&gt; TO &lt;newColumn&gt;;-- 修改表名SET CURRENT SCHEMA &lt;schema&gt;;ALTER TABLE &lt;table&gt; RENAME TO &lt;newTable&gt;; 删除表1DROP TABLE &lt;table&gt;; 参考 循序渐进DB2 （第5章）IBM Knowledge Center]]></content>
      <categories>
        <category>Database</category>
        <category>DB2</category>
      </categories>
      <tags>
        <tag>DB2</tag>
        <tag>Table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux磁盘操作]]></title>
    <url>%2Flinux%2Flinux%E7%A3%81%E7%9B%98%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Linux下磁盘分区、格式化、挂载 本文中的命令需要以 root用户操作 磁盘分区使用 fdisk命令进行磁盘分区 (无法处理大于2TB以上的磁盘分区，若磁盘大于2TB可使用 parted命令)12345678910fdisk -l # 找出需要分区的磁盘名称fdisk /dev/sdb # /dev/sdb 后面不要接数字# fdisk常用操作# m print this menu # 查看 fdisk帮助手册# d delete a partition # 删除分区# n add a new partition # 新增分区# p print the partition table # 打印分区信息# q quit without saving changes # 退出 fdisk，不保存当前操作# w write table to disk and exit # 保存退出 若使用 fdisk分区保存之后若发现找不到分区，可使执行如下命令1partproba # 强制让内核重新加载分区表 分区注意事项： 一个磁盘仅能存在4个主分区，当磁盘分配了4个主分区后将不能继续对磁盘进行分区； 一个磁盘仅能存在1个扩展分区，扩展分区下可以分配多个逻辑分区； 磁盘下需要分配多个分区的方式：3个主分区 + 1个扩展分区， 扩展分区下继续分配逻辑分区； 格式化分区使用 mkfs综合命令进行磁盘分区12345mkfs [tab] [tab] # 当前系统可格式化的文件系统类型mkfs.&lt;FileSystem&gt; -help # 查看帮助，&lt;FileSystem&gt;替换成具体的文件系统名，如： ext4# 示例：mkfs.ext4 -c /dev/sdb1 # -c 格式化指定分区 sdb1 挂载使用 mount挂载设备文件123456789101112mount -amount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 设备文件名 挂载点# 参数： -a 根据 /etc/fstab的内容，将所有未挂载的磁盘都挂载上来 -t 指定挂载的文件系统类型，如挂载磁盘： -t iso9660 -n 不将挂载信息写入 /etc/mtab中 -L 使用文件系统的卷标名进行挂载 -o 挂载额外参数（default: rw, suid, dev, exec, auto, nouser, and async）# 示例：mount /dev/sdb1 /opt/ 使用 umount卸载设备文件12345678umount [-fn] 设备文件名称/挂载点# 参数： -f 强制卸载 -n 不更新 /etc/tmap# 示例：umount /dev/sdb1 设置开机挂载设置开机挂载只需要将挂载信息写入 /etc/fstab文件中即可，该文件挂载项有6个字段，分别如下： 第一列： 设备文件名/设备Label 第二列： 挂载点 第三列： 磁盘分区的文件系统 第四列： 文件系统参数 （mount -o 指定的额外参数）， 参数详情 第五列： 能否被 dump备份命令作用（0： 不做 dump备份 / 1： 每天进行 dump操作） 第六列： 是否以 fsck检查扇区（0：不检查 / 1：较早检查 / 2：需要检查） 文件系统参数 参数 说明 ro/rw 挂载文件系统成为只读(ro) 或可擦写(rw) async/sync 此文件系统是否使用同步写入 (sync) 或异步 (async) 的内存机制。默认为 async。 auto/noauto 允许此 partition 被以 mount -a 自动挂载(auto) dev/nodev 是否允许此 partition 上，可创建装置文件？ dev 为可允许 suid/nosuid 是否允许此 partition 含有 suid/sgid 的文件格式？ exec/noexec 是否允许此 partition 上拥有可运行 binary 文件？ user/nouser 是否允许此 partition 让任何使用者运行 mount ？一般来说，mount 仅有 root 可以进行，但下达 user 参数，则可让一般 user 也能够对此 partition 进行 mount 。 defaults 默认值为：rw, suid, dev, exec, auto, nouser, and async remount 重新挂载，这在系统出错，或重新升级参数时，很有用 挂载分区注意事项 单个文件系统不应挂载到多个挂载点（目录）中； 单个挂载点不应重复挂载多个文件系统； 应当使用空目录作为挂载点；若挂载点不为空目录，那么挂载了文件系统后，原目录下的文件将会暂时消失，直至卸载该文件系统 参考 鸟哥的Linux私房菜 - 基础学习篇 （第8章）]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Virtualbox共享文件夹]]></title>
    <url>%2Fvirtualbox%2Fvirtualbox%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%2F</url>
    <content type="text"><![CDATA[配置 VirtualBox共享文件夹 环境 VirtualBox 5.2.2 CentOS7 添加虚拟光驱在 VirtualBox管理器中选择需要设置共享文件夹的虚拟机（虚拟机必须关闭），并进行如下操作：1设置 -&gt; 存储 -&gt; 控制器IDE -&gt; 添加 虚拟 光驱 -&gt; 留空 安装增强功能 启动虚拟机，然后在 VirtualBox菜单栏选中 “设备 -&gt; 安装增强功能”此操作将挂载 VirtualBox工具包至虚拟机中（CentOS7 默认挂载至: /run/media/user/VBox_GAs_5.2.2） 安装增强工具包 123cd /run/media/gavin/VBox_GAs_5.2.2sudo ./VBoxLinuxAdditions.run # 安装增强工具包sudo reboot # 重启虚拟机 设置共享文件夹在 VirtualBox管理器中进行如下操作：1设置 -&gt; 共享文件夹 -&gt; 右键选择 &quot;固定分配&quot; -&gt; 添加共享文件夹 注：不要选择 “自动挂载”， 否则挂载共享文件夹会出现错误：/sbin/mount.vboxsf: mounting failed with the error: Protocol error 挂载共享文件夹登入虚拟机，执行如下命令：123su - # root用户操作mkdir /mnt/shared # 创建挂载目录mount -t vboxsf share /mnt/shared # 挂载共享文件夹 注：共享文件夹与虚拟机挂载目录名字不要相同]]></content>
      <categories>
        <category>VirtualBox</category>
      </categories>
      <tags>
        <tag>VirtualBox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DB2体系结构]]></title>
    <url>%2Fdatabase%2Fdb2%2Fdb2%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[DB2数据库体系结构 DB2体系结构图 DB2服务器环境变量1. 环境变量1set &lt;variable&gt;=&lt;value&gt; # 设置服务器变量 2.全局注册变量123db2set -all # 查看当前注册变量设置 ([g]全局、[i]实例)db2set -lr # 查询所有注册变量 (全局 + 实例)db2set &lt;variable&gt;=&lt;value&gt; -g # 设置全局注册变量 实例创建实例参考： DB2数据库安装 实例相关命令12345678db2ilist # 列出实例db2start # 启动实例db2stop [force] # 停止实例db2 force application all # 强制中断实例下所有连接（当无法停止实例时，可以先执行该操作）db2iauto -[on | off] &lt;instance_name&gt; # 自动起停实例db2 attach to &lt;instance_name&gt; # 连接实例db2 detach / db2 terminate # 断开实例db2idorp &lt;instance_name&gt; # 删除实例 (需要root权限) 配置实例1. 实例级注册变量123db2set &lt;variable&gt;=&lt;value&gt; [-i instance_name] # 设置实例级注册变量# egdb2set DB2COMM=TCPIP 2. 数据库管理配置文12345db2 get dbm cfg # 获取当前实例数据库管理文件配置db2 reset dbm cfg # 恢复默认配置db2 update dbm cfg using &lt;parameter_name&gt; &lt;value&gt; # 配置当前实例数据库管理文件参数# eg db2 update dbm cfg using SVCENAME=50000 DB2INSTANCE 变量 该变量主要用于实例间切换，但在Linux/Unix系统下实例名即为实例用户名，因此直接使用不同实例用户登陆进行实例切换123echo $DB2INSTANCE # 输出变量值set DB2INSTANCE=&lt;instance_name&gt; # 设置变量值get instance # 获取当前实例 数据库创建数据库创建数据库时默认生成三个表空间 SYSCATSPACE、TEMPSPACE1、USERSPACE11234567891011CREATE DATABASE &lt;db_name&gt; -- 创建数据库 AUTOMATIC STORAGE &lt;YES | NO&gt; -- 是否自动存储 ON &lt;path | drive&gt; -- 数据库路径 ALIAS &lt;db_alias&gt; -- 别名 USING CODESET &lt;code&gt; TERRITORY &lt;territory&gt; -- 代码页 COLLATE USING &lt;SYSTEM | IDENTITY | ...&gt; -- 整理次序 CATALOG TABLESPACE &lt;tablespace_option&gt; -- 系统编目表空间 USER TABLESPACE &lt;tablespace_option&gt; -- 用户表空间 TEMPORARY TABLESPACE &lt;tablespace_option&gt; -- 临时表空间 -- 大写为关键字 示例：1234567create database test automatic storage yes on /data/db2/data -- 使用自动存储管理 dbpath on /data/db2/log -- 指定数据库的事物日志存储路径 using codeset utf-8 -- 指定字符集 territory CN -- 决定数据库的时间和日期格式为中文 pagesize 16 k -- 数据库默认页大小 alias test; -- 别名 数据库相关操作12db2 list database directory # 列出当前实例下所有数据库db2 drop database &lt;database_name&gt; # 删除数据库 配置数据库1234db2 get db cfg # 获取当前据库配置文件参数设置db2 update db cfg using &lt;parameter_name&gt; &lt;value&gt; # 配置当前数据库参数文件#eg:db2 update db cfg using LOGPRIMARY 50 缓冲池 每个表空间都会与特定的缓冲池相关； 想要表空间与缓冲池相关，该缓冲池与表空间必须具有相同的页大小； 表空间与缓冲池关联是在使用 CREATE TABLESPACE 语句创建表空间时定义的，但是可以使用 ALTER TABLESPACE 语句更改关联。 创建缓冲池12345CREATE BUFFERPOOL &lt;bufferpool_name&gt; -- 缓冲池名称 SIZE &lt;AUTOMATIC | size_number&gt; -- 缓冲池大小，即页数 PAGESIZE &lt;pagesize&gt; -- 缓冲池页大小 BLOCKSIZE &lt;number&gt; -- 可选参数： 指定每个块的大小，即在一次块I/O中从磁盘读取的页的数量。应该等于正在使用缓冲池的表空间的 EXTENTSIZE 的整数倍。 NUMBLOCKPAGES &lt;number&gt; -- 可选参数： 定义块内存大小。应该是 BLOCKSIZE 的倍数，并且不能大于缓冲池页面数量的 98%。 示例：1CREATE BUFFERPOLL MYBUFFER16K SIZE AUTOMATIC PAGESIZE 16K; 缓冲池相关操作1. 修改缓冲池1ALTER BUFFERPOOL &lt;name&gt; SIZE &lt;tgt_size&gt; 2. 查看缓冲池12345SELECT T2.TBSPACE ,T1.*FROM SYSCAT.BUFFERPOOLS T1INNER JOIN SYSCAT.TABLESPACES T2ON T1.BUFFERPOOLID = T2.BUFFERPOOLID 表空间创建表空间1. 创建用户表空间123456789-- SMSCREATE TABLESPACE &lt;name&gt; MANAGED BY SYSTEM USING (&apos;&lt;path&gt;&apos;); -- DMSCREATE TABLESPACE &lt;name&gt; MANAGED BY DATABASE USING (DEVICE | FILE &apos;&lt;path&gt;&apos;); - DMS自动存储CREATE TABLESPACE &lt;name&gt;; CREATE TABLESPACE &lt; name &gt; MANAGED BY AUTOMATIC STORAGE; 2. 创建系统临时表空间1CREATE SYSTEM TEMPORARY TABLESPACE tmp_tbsp MANAGED BY SYSTEM USING (&apos;/data/tmp_tbsp&apos;); 3. 创建用户临时表空间1CREATE USER TEMPORARY TABLESPACE usr_tbsp MANAGED BY DATABASE USING (FILE &apos;/data/usr_tbsp&apos; 5000); 示例:12345678CREATE TEMPORARY TABLESPACE tbs_temp PAGESIZE 16K MANAGED BY DATABASE USING（FILE &apos;/data/&apos; 1000） EXTENTSIZE 32 OVERHEAD 10.67 PREFECHSIZE 32 TRANSFERRATE 0.04 BUFFERPOOL MYBUFFER16K； 表空间相关操作1. 查看表空间12db2 list tablespaces [show detail] # 查看表空间db2 list tablespace containers for &lt;tablespace_id&gt; # 查看表空间及容器属性 2. 修改表空间12345678910# 2.1. SMS表空间只能增加容器；ALTER TABLESPACE &lt;name&gt; ADD(DEVICE &apos;&lt;path&gt;&apos; &lt;size&gt;, FILE &apos;&lt;filename&gt;&apos; &lt;size&gt;);# 2.2. DMS表空间可以调整容器；ALTER TABLESPACE &lt;name&gt; REDUCE (FILE &apos;&lt;filename&gt;&apos; &lt;size&gt;); # 缩小ALTER TABLESPACE &lt;name&gt; EXTEND (FILE &apos;&lt;filename&gt;&apos; &lt;size&gt;); # 增大ALTER TABLESPACE &lt;name&gt; RESIZE (FILE &apos;&lt;filename&gt;&apos; &lt;size&gt;); # 调增 （可调小或调大）ALTER TABLESPACE &lt;name&gt; DROP (FILE &apos;filename&apos;, DEVICE &apos;path&apos;); # 删除DMS容器# 2.3. 自动存储表空间不能手动调整大小； 3. 重命名表空间1RENAME TABLESPACE &lt;srcName&gt; TO &lt;tgtName&gt;; 4. 将表空间从托机状态切换至联机状态1ALTER TABLESPACE &lt;name&gt; SWITCH ONLINE; 5. 删除表空间1DROP TABLESPACE &lt;name&gt;; 参考 循序渐进DB2 （第2章~第3章）]]></content>
      <categories>
        <category>Database</category>
        <category>DB2</category>
      </categories>
      <tags>
        <tag>DB2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DB2数据库安装]]></title>
    <url>%2Fdatabase%2Fdb2%2Fdb2%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[安装DB2数据库 环境CentOS 7DB2 Express-C v10.1 (db2_v101_linuxx64_expc.tar.gz) 安装DB21. 解压安装包 1tar -zxvf db2_v101_linuxx64_expc.tar.gz -C /opt 2. 执行安装db2_install 默认安装目录为 /opt/ibm/db2， 可以通过 -b指定安装目录， -h 帮助 123su - # root用户cd /opt/expc # 进入安装目录./db2_install # 以root用户安装DB2 安装实例1. 创建实例相关用户在Linux/Unix上创建实例时必须有与实例同名用户存在；实例用户的home目录，是创建实例的位置；受防护用户(db2fenc1)与应用开发相关，但是作为创建实例却是必须的。 12345# root用户执行以下命令groupadd -g 2000 db2iadm1 # 实例用户组groupadd -g 2001 db2fadm1 # 受防护组useradd -m -u 2000 -g db2iadm1 db2inst1 # 实例用户useradd -m -u 2001 -g db2fadm1 db2fenc1 # 受防护用户 2. 实例安装可以直接键入 ./db2icrt 获取命令帮助信息；Linux/Unix下 /home/实例用户/sqllib/ 目录为实例目录，实例目录一旦创建不能更改其位置。 123# root用户执行以下命令cd /opt/ibm/db2/V10.1/instance # 实例安装目录./db2icrt -p 50000 -u db2fenc1 db2inst1 # 实例安装-p &lt;端口号&gt; -u &lt;受防护用户&gt; &lt;实例用户&gt; 安装数据库使用db2实例用户创建数据库1. 创建数据库目录1234su - # root用户mkdir /data/db2/data # 创建数据库目录mkdir /data/db2/log # 创建数据库事物日志目录chown -R db2inst1:db2inst1 /data/db2/ # 赋权给 db2实例用户 2. 创建数据库123456789su - db2inst1 # db2inst1用户 db2start # 启动实例 # 创建数据库db2 "create database test automatic storage yes on /data/db2/data dbpath on /data/db2/log using codeset utf-8 territory CN pagesize 8 k" 配置 DB2运行环境可以通过引用 InstanceHome/sqllib/db2profile 文件来配置其他用户 DB2 运行环境在用户目录下 .bash_profile 文件中加入如下配置123if [ -f /home/db2inst1/sqllib/db2profile ]; then . /home/db2inst1/sqllib/db2profilefi 配置 DB2服务器的 TCP/IP通信1. 标识 “服务名称”和 “连接端口” 或 仅标识 ”连接端口” 方式一： 标识 ”连接服务名称” 和 “连接端口” 在 数据库管理器配置文件 中的 SVCENAME（服务名）指定 “服务名称”12db2 get dbm cfg | grep SVCENAME #获取当前数据库管理器配置文件中服务名db2 update dbm cfg using SVCENAME db2inst1 #设置数据库管理器配置文件中服务名为： db2inst1 在 /etc/services 配置文件中添加与修改后服务名称一致的对应端口号1db2inst1 50000/tcp 方式二： 仅标识 “连接端口” 1db2 update dbm cfg using SVCENAME 50000 2. 设置服务器的通信协议 1db2set DB2COMM=tcpip 配置 DB2 客户端通信节点目录123456-- 列出节点db2 list node directory-- 编目节点db2 catalog tcpip node &lt;node_name&gt; remote &lt;host_name | ip&gt; server &lt;port_name | port&gt; -- 删除节点 db2 uncatalog node &lt;node_name&gt; 数据库目录123456-- 列出数据库db2 list db directory -- 编码数据库db2 catalog db &lt;db_name&gt; as &lt;db_alias&gt; at node &lt;node_name&gt; -- 删除数据库db2 uncatalog db &lt;db_alias&gt;]]></content>
      <categories>
        <category>Database</category>
        <category>DB2</category>
      </categories>
      <tags>
        <tag>DB2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL脚本编码规范]]></title>
    <url>%2Fsql%2Fsql%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[良好的编码习惯可以减少出问题的几率和后期代码维护的成本 基本要求 脚本文件名称使用小写，单词与单词间使用下划线分割，最好对应于操作的表名 脚本采用 UTF-8编码， UNIX格式 脚本必须写好基本注释信息（如： 脚本功能，加载时机频率，开发人员…） 编写规范注释编写SQL脚本中无论单行、多行注释均用 –标识，不使用块状注释 / / 12345678-- 脚本名称： demo.sql-- 脚本功能： sql脚本示例-- 加载频率： d-- 创建人： gavin-- 创建时间： 2017-12-04-- 修改人：-- 修改时间：-- 修改说明： 字段排列 每个查询字段独占一行 分割字段的逗号置于字段名称之前 查询字段写好注释 12345select field1 -- 字段1 ,field2 -- 字段2 ,field3 -- 字段3from test.demo -- 示例表; 子句排列同一级别的子句要对齐 123456789select a.field1 -- 字段1 ,a.field2 -- 字段2 ,b.field3 -- 字段3from test.tab1 a -- 表1inner join test.tab2 b -- 表2on a.field1 = b.field1where a.field2 = ''order by a.field1; 子句查询嵌套子句嵌套编排做好层次分明 12345678910select a.field1 -- 字段1 ,a.field2 -- 字段2 ,a.field3 -- 字段3from test.tab1 a -- 表1where a.field2 = ''and exists ( select 1 from test.tab2 b -- 表2 where a.field1 = b.field1 ); 字段别名 如查询字段的名称与目标表字段名称不一致，则使用 AS为字段命别名 若查询字段或表达式过长，则 AS最好分行对齐 123456789101112insert into test.tgt ( -- 目标表 field1 -- 字段1 ,field2 -- 字段2 ,field3 -- 字段3)select field1 ,'xxx' AS field2 ,express1 || express2 || express 3 AS field3from test.src -- 目标表;commit; 表别名多表嵌套查询需体现层次结构，可为表命别名。使用字母 a-z标明层次, 同一层次间使用数字标明序号 1234567891011select a1.field1 -- 字段1 a2.field2 -- 字段2from test.tab1 a1innser join ( select b1.field2 as field1 ,b2.field2 from test.tab2 b1 inner join test.tab3 b2 on b1.field1 = b2.field1 ) a2on a1.field1 = a2.field1; 特殊表命名规范 历史表： 以h结尾 临时表： 以tmp结尾 备份表： 以8位备份日期结尾]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Class对象]]></title>
    <url>%2Fjava%2Fclass%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[概述 每个类都有一个Class对象； 类Class对象是由JVM的子系统 “类加载器”生成的。 类加载器类加载器实际上可以包含一条加载器链，但是只有一个原声类加载器，可以挂接额外类加载器 原生类加载器原生类加载的是所谓的可信类，如：JavaAPI等 额外类加载器额外类加载器用来满足自身的特殊需求，如：以某种特殊方式加载类，以支持WEB服务器应用等 类的动态加载类的动态加载分为三个步骤： 加载由类加载器执行，该步骤将查找字节码，并从字节码中创建一个Class对象 链接链接将验证类中的字节码，为静态域分配存储空间，并且如果必须的话将解析这个类创建其它类的所有引用 初始化如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块 “惰性”初始化当程序创建第一个对类的静态成员的引用时，就会 加载 该类；根据java虚拟机规范，所有java虚拟机实现必须在每个类或接口被java程序首次 主动使用 时才初始化。 主动使用有如下几种 创建类的实例 访问某个类或者接口的静态域（静态变量、方法） 如果访问静态编译时常量(static final)不会导致类的初始化 构造方法也是类的静态方法，因此使用 new关键字会被当成是对静态成员的引用 12345678910111213141516171819202122232425262728293031323334package org.gavin.clazz;class LazyInitialization1 &#123; static final int FIELD = 0; static int FIELD1 = 1; static &#123; System.out.println("Initial"); &#125;&#125;/** * &lt;p&gt;如果 static域是final的，那么不对类进行初始化也可以进行读取； * &lt;p&gt;若 static域不是final的，那在读取之前进行链接（为这个域分配空间）和初始化（初始化该空间）。 * * @author gavin */public class ClassInitialize1 &#123; public static void main(String[] args) &#123; System.out.println("static final"); System.out.println(LazyInitialization1.FIELD); System.out.println("static"); System.out.println(LazyInitialization1.FIELD1); &#125;&#125;// 输出结果：static final0staticInitial1 反射（Class.forName(xxx.xxx.xxx)） 123456789101112131415161718192021222324252627282930package org.gavin.clazz;class LazyInitialization &#123; static &#123; System.out.println("Initial"); &#125;&#125;/** * &lt;p&gt;使用类字面常量 .class 来创建对Class对象的引用时，不会自动初始化该Class对象; * &lt;p&gt;但是使用 Class.forName() 会立即进行初始化。 * * @author gavin */public class ClassInitialize &#123; @SuppressWarnings("unused") public static void main(String[] args) throws ClassNotFoundException&#123; System.out.println(".class"); Class&lt;LazyInitialization&gt; clazz = LazyInitialization.class; System.out.println("Class.forName()"); Class.forName("org.gavin.clazz.LazyInitialization"); &#125;&#125;// 输出结果：.classClass.forName()Initial 初始化一个类的子类（相当于对父类的主动使用），不过直接通过子类引用父类元素，不会引起子类的初始化 123456789101112131415161718192021222324252627package org.gavin.clazz;class Parent &#123; static int field = 0; static &#123; System.out.println("parent"); &#125;&#125;class Child extends Parent&#123; static &#123; System.out.println("child"); &#125;&#125;/** *当访问一个Java类或接口的静态域时，只有真正声明这个域的类或接口才会被初始化 */public class ClassInitialize2 &#123; public static void main(String[] args) &#123; System.out.println(Child.field); &#125;&#125;// 输出结果：parent0 Java虚拟机被标明为启动类的类（包含main方法的类） 获取Class对象 类字面量常量 .class 反射 Class.forName( ) 实例对象 obj.getClass 参考 Java编程思想 （14章）Java系列笔记(1) - Java 类加载与初始化]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
</search>
